#!/usr/bin/env ruby

require 'rubygems'
require 'builder'
require 'hpricot'
require 'yaml'
require 'fileutils'

def parse_title(doc)
  t = doc.search("title").inner_html.gsub(/[\n ]+/, " ").strip
  t = t.sub(/ *(-|&mdash;)* bioconductor\.org/, "")
  if /folder listing/i.match(t)
    nil
  else
    t
  end
end

def parse_attributes(doc)
  attrs = {}
  doc.search("meta").each do |meta_tag|
    name = meta_tag["name"]
    next unless name
    case name
    when /^DC\./
      attrs[name] = meta_tag["content"]
    end
  end
  attrs["title"] = parse_title(doc)
  attrs["plone_url"] = doc.search("base")[0]["href"] rescue ""
  attrs
end

def parse_content(doc)
  c = doc.search("div.plain")
  if c.empty?
    c = doc.search("div.documentContent")
  end
  if c.empty?
    c = doc.search("body")
  end
  if !c.empty?
    c.search("img[@src='']").remove
    c.search("img").collect! do |node|
      if /_icon\.gif/.match(node["src"])
        node
      else
        nil
      end
    end.compact.remove
    c.search("div").collect! {|n| n if n.empty? }.compact.remove
    c.search("a.link-parent").remove
    c.search("a").each do |a|
      a.remove_attribute("target") if a["target"]
      if a["href"]
        if not /(^http|^mailto)/i.match(a["href"])
          case a["href"]
          when /index\.html$/
            a["href"] = a["href"].sub(/index\.html$/, "")
          when /index_html/
            a["href"] = a["href"].sub(/index_html/, "")
          when /\.html$/
            a["href"] = a["href"].sub(/\.html$/, "/")
          end
        end
      end
    end
    c.search("a#documentContent").remove
    c.search("div.documentDescription").remove
    c.search("div.discussion").remove
    c[0].traverse_all_element do |e|
      if e.elem?
        e.remove_attribute("class") if e["class"]
        e.remove_attribute("id") if e["id"]
      end
    end
    c.inner_html
  else
    nil
  end
end

def create_file_index(dir)
  # TODO: could set a class based on whether item is
  # a file or a directory.  For files we could compute size
  # and directories possibly number of items inside.
  adir = File.expand_path(dir)
  xm = Builder::XmlMarkup.new(:indent => 2, :margin => 8)
  content = xm.ul("class" => "file_list") {
    Dir.chdir(adir) do
      Dir["*"].each do |f|
        # For the benefit of the preview webserver
        # we append a trailing slash to directories
        # otherwise the dir/index.html is not found.
        if File.directory?("#{adir}/#{f}")
          f += "/"
        end
        xm.li { xm.a(f, "href" => "#{f}") }
      end
    end
  }.to_s
  attrs = {
    "title" => "#{File.basename(adir)}",
    "created_at" => Time.now.to_s,
    "autogenerated" => "true"
  }
  { :content => content, :attrs => attrs }
end

def rewrite_workshop(f)
  orig = ""
  new = "/help/course-materials/"
  case f
  when /index\.html$/
    fdir = File.dirname(f)
    orig = "#{fdir}/?(index\\.html)?$"
    new += File.dirname(f)
  else
    orig = f
    new += f.sub(/\.html$/, "")
  end
  "RewriteRule ^workshops/#{orig} #{new}/ [R=301]"
end

##
# import plone workshop index_html into nanoc content
#
# input should be the path to the workshops directory
# as exported from Plone containing the index_html files
#
# content should be the path to the nanoc content directory.
def import_workshop_index_files(input, content)
  indir = File.expand_path(input)
  outdir = File.expand_path(content)
  workshop_out_dir = "#{outdir}/course-materials"
  rewrites = []
  Dir.chdir(input) do
    Dir["**/*"].each do |f|
      if File.fnmatch("*.html", File.basename(f))
        print "processing: #{f} "
        dest_dir = "#{workshop_out_dir}/#{File.dirname(f)}".sub(/\/$/, "")
        if !File.fnmatch("index.html", File.basename(f))
          dest_dir = "#{workshop_out_dir}/#{f}".sub(/\.html$/, "")
        end
        rewrites << rewrite_workshop(f)
        FileUtils.mkdir_p(File.dirname(dest_dir))
        if !File.size?("#{indir}/#{f}")
          puts "<empty>"
          next
        end
        doc = Hpricot(open("#{indir}/#{f}"))
        attrs = parse_attributes(doc)
        if attrs["title"].nil?
          attrs["title"] = File.basename(dest_dir)
        end
        print "A"
        content = parse_content(doc)
        if content.nil?
          puts "No content for #{indir}/#{f}"
          next
        end
        puts "C"
        open("#{dest_dir}.html", "w") do |out|
          out.write(content)
        end
        open("#{dest_dir}.yaml", "w") do |out|
          out.write(attrs.to_yaml)
        end
      end
    end
  end
  open("workshop_rewrites.txt", "w") { |f| f.write(rewrites.join("\n")) }
end

def autogenerated?(f)
  attrs = YAML.load_file(f)
  k = "autogenerated"
  (attrs.has_key?(k) && attrs[k].downcase != "false")
end

def build_file_index_files(input, content)
  indir = File.expand_path(input)
  outdir = File.expand_path(content)
  workshop_out_dir = "#{outdir}/#{File.basename(indir)}"
  Dir.chdir(input) do
    Dir["**/"].each do |d|
      d = d.sub(/\/$/, "")
      dest_html = "#{workshop_out_dir}/#{d}.html"
      dest_yaml = "#{workshop_out_dir}/#{d}.yaml"
      if !File.exists?(dest_yaml) || autogenerated?(dest_yaml)
        puts "Updating index for: #{dest_html}"
        ans = create_file_index(d)
        FileUtils.mkdir_p(File.dirname(dest_html))
        open(dest_html, "w") { |fh| fh.write(ans[:content]) }
        open(dest_yaml, "w") { |fh| fh.write(ans[:attrs].to_yaml) }
      end
    end
  end
end

if __FILE__ == $0
  #build_file_index_files("plone-bioconductor.org/workshops", "content")
  import_workshop_index_files("../_MIRROR/bioconductor.org/workshops",
                              "content/help")
end

