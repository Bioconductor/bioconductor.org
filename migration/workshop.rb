#!/usr/bin/env ruby

require 'rubygems'
require 'builder'
require 'hpricot'
require 'yaml'

def parse_title(doc)
  doc.search("title").inner_html.gsub(/[\n ]+/, " ").strip
end

def parse_attributes(doc)
  attrs = {}
  doc.search("meta").each do |meta_tag|
    name = meta_tag["name"]
    next unless name
    case name
    when /^DC\./
      attrs[name] = meta_tag["content"]
    end
  end
  attrs["title"] = parse_title(doc)
  attrs["plone_url"] = doc.search("base")[0]["href"]
  attrs
end

def parse_content(doc)
  c = doc.search("div.plain")
  if c.empty?
    c = doc.search("div.documentContent")
  end
  if !c.empty?
    c.inner_html
  else
    nil
  end
end

def create_file_index(dir)
  # TODO: could set a class based on whether item is
  # a file or a directory.  For files we could compute size
  # and directories possibly number of items inside.
  adir = File.expand_path(dir)
  xm = Builder::XmlMarkup.new(:indent => 2, :margin => 8)
  content = xm.ul("class" => "file_list") {
    Dir.chdir(adir) do
      Dir["*"].each do |f|
        # For the benefit of the preview webserver
        # we append a trailing slash to directories
        # otherwise the dir/index.html is not found.
        if File.directory?("#{adir}/#{f}")
          f += "/"
        end
        xm.li { xm.a(f, "href" => "#{f}") }
      end
    end
  }.to_s
  attrs = {
    "title" => "#{File.basename(adir)}",
    "created_at" => Time.now.to_s,
    "autogenerated" => "true"
  }
  { :content => content, :attrs => attrs }
end

##
# import plone workshop index_html into nanoc content
#
# input should be the path to the workshops directory
# as exported from Plone containing the index_html files
#
# content should be the path to the nanoc content directory.
def import_workshop_index_files(input, content)
  indir = File.expand_path(input)
  outdir = File.expand_path(content)
  workshop_out_dir = "#{outdir}/course-materials"
  Dir.chdir(input) do
    Dir["**/*"].each do |f|
      if File.fnmatch("index[._]html", File.basename(f))
        puts "processing: #{input}/#{f}"
        dest_dir = "#{workshop_out_dir}/#{File.dirname(f)}".sub(/\/$/, "")
        # FIXME: handle case when dirname(f) == "."
        FileUtils.mkdir_p(File.dirname(dest_dir))
        if !File.size?("#{indir}/#{f}")
          puts "empty file, skipping"
          next
        end
        doc = Hpricot(open("#{indir}/#{f}"))
        print "."
        attrs = parse_attributes(doc)
        print "."
        content = parse_content(doc)
        if content.nil?
          puts "No content for #{indir}/#{f}"
          next
        end
        puts "."
        open("#{dest_dir}.html", "w") do |out|
          out.write(content)
        end
        open("#{dest_dir}.yaml", "w") do |out|
          out.write(attrs.to_yaml)
        end
      end
    end
  end
end

def autogenerated?(f)
  attrs = YAML.load_file(f)
  k = "autogenerated"
  (attrs.has_key?(k) && attrs[k].downcase != "false")
end

def build_file_index_files(input, content)
  indir = File.expand_path(input)
  outdir = File.expand_path(content)
  workshop_out_dir = "#{outdir}/#{File.basename(indir)}"
  Dir.chdir(input) do
    Dir["**/"].each do |d|
      d = d.sub(/\/$/, "")
      dest_html = "#{workshop_out_dir}/#{d}.html"
      dest_yaml = "#{workshop_out_dir}/#{d}.yaml"
      if !File.exists?(dest_yaml) || autogenerated?(dest_yaml)
        puts "Updating index for: #{dest_html}"
        ans = create_file_index(d)
        FileUtils.mkdir_p(File.dirname(dest_html))
        open(dest_html, "w") { |fh| fh.write(ans[:content]) }
        open(dest_yaml, "w") { |fh| fh.write(ans[:attrs].to_yaml) }
      end
    end
  end
end

if __FILE__ == $0
  #build_file_index_files("plone-bioconductor.org/workshops", "content")
  import_workshop_index_files("../_MIRROR/bioconductor.org/workshops",
                              "content")
end

