#!/usr/bin/env ruby

require 'rubygems'
require 'yaml'
#require 'builder'
require 'fileutils'

class AddCourse
  CMDS = ["create", "index", "sync"]

  def initialize
    verify_nanoc_dir()
    @config = YAML.load_file("config.yaml")
    @course_dir = "help/course-materials"
    @content_dir = "content"
  end

USAGE = <<EOF
Usage: #{$0} COMMAND DIR

COMMAND can be one of:

  create
      Create course content template directory named DIR in
      the current working directory.

  index
      Add course to courses list and create a course index content
      page.  This modifies and creates files within the site's content
      directory.  Uses template file and file structure found in DIR
      to create the index.

  sync
      Performs an rsync of DIR to live bioconductor.org webserver.

DIR
    Name of the course in the format suitable for use as directory
    name and URL path element.


EOF

COURSE_YAML = <<EOF
layout: course
title:
  The title of the course goes here
start_date: 2010-01-27
end_date: 2010-01-29
instructors: ["T. Cher", "Prof S. Or"]
location: "Seattle, USA"
url: COURSE_URL_HERE
tags: ["intro", "seattle", "package"]
description:
  You can put some description text here.
  Must be indented.
EOF

  def create(name)
    if File.exist?(name)
      $stderr.puts "#{name} already exists, aborting"
      exit 1
    end
    FileUtils.mkdir(name)
    config = "#{name}/course_config.yaml"
    open(config, "w") do |f|
      f.write(COURSE_YAML)
    end
    msg = <<EOF
Course directory created at: #{name}
NEXT STEPS:
    - edit #{config}
    - run ./scripts/add_course index #{name}
EOF
    puts msg
  end

  def index(name)
    # FIXME: test name for exist and yaml file too
    # FIXME: useful output if no files created (empty course dir)
    course = YAML.load_file("#{name}/course_config.yaml")
    bname = File.basename(name)
    year = course_year(course)
    create_year_index_page(year)
    course_path = year + "/" + bname
    course_out_dir = @content_dir + "/" + @course_dir + "/" + course_path
    material = make_material_list(name, [/course_config.yaml/])
    attrs = { "title" => bname, "created_at" => Time.now.utc,
      "autogenerated" => true }.merge(course)
    write_content(course_out_dir, { :content => material, :attrs => attrs})
    name = name.sub(/\/$/, "")
    rsync_src = "#{name}/"
    rsync_dst = @config["output_dir"] + "/" + @course_dir + "/" + course_path
    rsync_cmd = "rsync -a --exclude='*.yaml' #{rsync_src} #{rsync_dst}"
    msg = <<EOF
COPYING for preview:
    src: #{rsync_src}
    dst: #{rsync_dst}
    cmd: #{rsync_cmd}
EOF
    run_cmd("mkdir -p #{File.dirname(rsync_dst)}") 
    run_cmd(rsync_cmd)
    puts msg
    msg = <<EOF
NEXT STEPS:
    - preview site with 'rake devserver'
    - edit CREATED files to add descriptions for links
    - if happy, run ./scripts/add_course sync
EOF
    puts msg
  end

  def sync(name)
    name = name.sub(/\/$/, "")
    course = YAML.load_file("#{name}/course_config.yaml")
    src = "#{name}"
    deploy_root = @config["staging_deploy_root"]
    host, path = deploy_root.split(":")
    yearpath = "/" + @course_dir + "/" + course_year(course)
    dst = deploy_root + yearpath
    dir_cmd = "ssh #{host} mkdir -p #{path}#{yearpath}"
    cmd = "rsync -avR --exclude='*.yaml' #{src} #{dst}"
    msg = <<EOF
SYNC:
    src: #{src}
    dst: #{dst}
    cmd: #{dir_cmd}
    cmd: #{cmd}
EOF
    puts msg
    run_cmd(dir_cmd)
    run_cmd(cmd)
    msg = <<EOF
NEXT STEPS:
    - svn add/commit changes in contents/
    - wait 10 minutes for changes to propagate
    - verify content on live site
EOF
    puts msg
  end

  def course_year(course)
    course["start_date"].year.to_s
  end

  def autogenerated?(f)
    attrs = YAML.load_file(f)
    k = "autogenerated"
    (attrs.has_key?(k) && attrs[k].downcase != "false")
  end

  def create_year_index_page(year)
    outbase = @content_dir + "/" + @course_dir + "/" + year
    outhtml = outbase + ".html"
    outyaml = outbase + ".yaml"
    if !File.exist?(outhtml)
      open(outhtml, "w") do |f|
        f.write(%[<%= render("_course_year_summary", :year => @item) %>])
      end
    end
    if !File.exist?(outyaml)
      open(outyaml, "w") do |f|
        f.write({ "title" => year }.to_yaml)
      end
    end
  end

  def make_material_list(d, excludes = [])
    make_material_list1(d, [], 0, excludes).join("")
  end

  # markdown material list
  def make_material_list1(d, acc, indent = 0, excludes = [])
    s = lambda { |y, x| (" " * x) + y }
    link = lambda { |href|
      # strip leading dir
      href = href.split("/")[1..-1].join("/")
      "[#{File.basename(href)}](#{href})"
    }
    Dir["#{d}/*"].each do |f|
      next if excludes.map { |pat| pat.match(f) }.reduce(:|)
      if File.directory?(f)
        acc << s.call("* #{File.basename(f)}\n", indent)
        make_material_list1(f, acc, indent + 4)
      else
        acc << s.call("* " + link.call(f) + "\n", indent)
      end
    end
    acc
  end

  def write_content(base, data)
    dest_html = "#{base}.md"
    dest_yaml = "#{base}.yaml"
    FileUtils.mkdir_p(File.dirname(dest_html))
    open(dest_html, "w") { |fh| fh.write(data[:content]) }
    open(dest_yaml, "w") { |fh| fh.write(data[:attrs].to_yaml) }
    p = base.sub(/.*\/content\/(.*$)/, "\\1")
    puts "CREATED: #{p} (.md, .yaml)"
  end

  def verify_nanoc_dir
    must_have = ["content", "layouts", "lib"]
    all_there = must_have.map { |d| File.directory? d }.reduce(:&)
    if (!all_there)
      $stderr.puts("Current directory does not look like site root.  " +
                   "Expecting to find:")
      $stderr.puts(must_have.join(", "))
      exit 1
    end
    if !(File.directory?("output"))
      $stderr.puts("Please run 'rake' to compile the site before running" +
                   " this script")
      exit 1
    end
  end

  def verify_args(cmd, course_dir)
    if (!cmd || !CMDS.member?(cmd))
      $stderr.puts USAGE
      msg = cmd ? "unknown COMMAND: #{cmd}" : "missing COMMAND"
      $stderr.puts msg
      exit 1
    end

    if !course_dir
      $stderr.puts USAGE
      $stderr.puts "missing DIR" if !course_dir
      exit 1
    end
  end

  def run_cmd(cmd)
    raise "command failed: #{cmd}" unless system(cmd)
  end

  def run(args)
    verify_nanoc_dir()
    cmd = args[0]
    course_dir = args[1]
    verify_args(cmd, course_dir)
    self.send(cmd.to_sym, course_dir)
  end
end


#adder = AddCourse.new
#adder.run(ARGV)
puts "./scripts/add_course has been deprecated and replaced with ./scripts/course_mgr."
puts "run ./scripts/course_mgr for usage information."
